#ifndef ADDITIONALTESTING_H
#define ADDITIONALTESTING_H

/* * ***** PASTE THE FOLLOWING TO MAIN FUNCTION AS NEEDED  ******
//this is some more testing for stack, que, list classes.

print("----testing starts here-----");
    cout << endl;

//    print("Stack of other other data types");
//    print("Stack of queues");
//    Stack<Que<char>> JackGenius;
//    Que<char> Jack, genius;
//    string str1 = "Jack";
//    string str2 = "genius";
//    for(string::iterator it = str1.begin(); it!=str1.end();it++)
//        Jack.push(*it);
//    for(string::iterator it = str2.begin(); it!=str2.end();it++)
//        genius.push(*it);
//    JackGenius.push(genius);
//    JackGenius.push(Jack);

//    print("que 1:");
//    print(Jack);
//    print("que 2: ");
//    print(genius);
//    print("stack of que 1 + que 2");
//    print(JackGenius);



//    print("Stack of strings");
//    Stack<string> s;
//    s.push("Genius");
//    s.push("a");
//    s.push("is");
//    s.push("Jack");
//    print(s);
//    print("Queue of strings");
//    Que<string> q;
//    q.push("Jack");
//    q.push("is");
//    q.push("a");
//    q.push("genius");
//    print(q);









//    print("outputting an empty list");
//    List<int> l;
//    print(l);

//    print("calling the copy constructor with source being empty");
//    List<int> l2(l);
//    print(l2);

//    print("calling assignment operator with source being empty");
//    List<int> l3;
//    l3 = l2;
//    print(l3);

//    print("accessing the top  of an empty list");
//    print(*l.begin());

//    print("accessing the end of an empty list");
//    print(*l.end());

//    print("push item to empty list then access its top AND end");
//    l.insert(1);
//    print("top: ");
//    print(*l.begin());
//    print("end: ");
//    print(*l.end());

//    cout << endl;
//    print("assigning an empty list to a non-empty list");
//    l = l2;
//    print("destination: ");
//    print(l);
//    print("source:");
//    print(l2);



    //    cout << endl;
    //    print("assigning an empty stack to a non-empty stack");
    //    s = s2;
    //    print("destination: ");
    //    print(s);
    //    print("source:");
    //    print(s2);


//    print("outputting an empty stack");
//    Stack<int> s;
//    print(s);

//    print("calling the copy constructor with source being empty");
//    Stack<int> s2(s);
//    print(s2);

//    print("calling assignment operator with source being empty");
//    Stack<int> s3;
//    s3 = s2;
//    print(s3);

//    print("accessing the front of an empty stack");
//    print(s.top());

//    print("push item to empty stack then access its top");
//    s.push(1);
//    print(s.top());

//    cout << endl;
//    print("assigning an empty stack to a non-empty stack");
//    s = s2;
//    print("destination: ");
//    print(s);
//    print("source:");
//    print(s2);


//    cout << endl;
//    print("assigning an empty queue to a non-empty queue");
//    q = q2;
//    print("destination: ");
//    print(q);
//    print("source:");
//    print(q2);


//    print("outputting an empty queue");
//    Que<int> q;
//    print(q);

//    print("calling the copy constructor with source being empty");
//    Que<int> q2(q);
//    print(q2);

//    print("calling assignment operator with source being empty");
//    Que<int> q3;
//    q3 = q2;
//    print(q3);

//    print("accessing the front of an empty queue");
//    print(q.front());

//    print("push item to empty queue then access its front");
//    q.push(1);
//    print(q.front());

//    cout << endl;
//    print("assigning an empty queue to a non-empty queue");
//    q = q2;
//    print("destination: ");
//    print(q);
//    print("source:");
//    print(q2);

 *
 *
 */
#endif // ADDITIONALTESTING_H
